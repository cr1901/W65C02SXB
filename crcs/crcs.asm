.INCLUDE "header.inc"
.INCLUDE "macros.inc"

; Generated from C source in: http://www.ross.net/crc/download/crc_v3.txt.
; Although 16 entry tables could be done by hand if you had to.
;
; A 256-table entry can be generated by doing two nibbles XOR'ed together,
; where H_entry is high nibble and L_entry is low nibble.
; TODO: Assuming I didn't screw up the below formula... Potential optimization?
;
; (table[H_entry] << 4) ^ table[((table[H_entry] >> 12) ^ L_entry)]

; CRC-16/XMODEM
.BANK 0 SLOT 1
.SECTION "CRCTables"
xmodem_crc_table .DW 0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7, \
            0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF

; A refin/refout = true nibble table uses table entries 0, 0x10, 0x20, 0x30, etc
; because the message is shifted in LSB first. So we chomp the _trailing_ zero
; as a noop.
; The math works out, trust me. I did hand calculations.
kermit_crc_table .DW 0x0000, 0x1081, 0x2102, 0x3183, 0x4204, 0x5285, 0x6306, 0x7387, \
    0x8408, 0x9489, 0xA50A, 0xB58B, 0xC60C, 0xD68D, 0xE70E, 0xF78F
.ENDS

.RAMSECTION "CRCZP" SLOT 0
crc_xorval: DW
.ENDS

.RAMSECTION "CRCVars" SLOT 0 ORG $200

.ENDS

.BANK 0 SLOT 1
.SECTION "ENTRY"
entry:
    ldy #1
    jsr init_crc

@next:
    lda.w check,Y
    jsr process_byte_rev
    iny
    cpy.w check
    BLE @next

@done:
    sta.w BUS0
    jmp @done

init_crc:
    STZ16 crc_xorval
    rts

process_byte:
    jsr process_nibble
    jsr process_nibble_lo
    rts

process_nibble_lo:
    pha
    asl
    asl
    asl
    asl
    jmp process_nibble@lo_begin

; Hi nibble, most-significant-bit is the one processed first.
process_nibble_hi:
process_nibble:
    pha
@lo_begin:
    eor crc_xorval + 1 ; XOR the high nibble of the last CRC val.
    lsr
    lsr
    lsr
    lsr
    asl ; Each table entry is 16 bits.
    pha ; Save it

    ; Get rid of high nibble of CRC.
    ldx #4
@shift:
    asl crc_xorval
    rol crc_xorval + 1
    dex
    bne @shift

    ; Index into CRC table.
    plx
    lda.w xmodem_crc_table,X
    eor crc_xorval
    sta crc_xorval
    lda.w xmodem_crc_table + 1,X
    eor crc_xorval + 1
    sta crc_xorval + 1

    pla
    rts

; Low nibble, least-significant-bit is the one processed first.
process_byte_rev:
    jsr process_nibble_rev
    jsr process_nibble_hi_rev
    rts

process_nibble_hi_rev:
    pha
    lsr
    lsr
    lsr
    lsr
    jmp process_nibble_rev@hi_begin

; Low nibble, least-significant bit is the one processed first.
process_nibble_lo_rev:
process_nibble_rev:
    pha
@hi_begin:
    eor crc_xorval ; XOR the low nibble of the last CRC val.
    and #%00001111
    asl ; Each table entry is 16 bits.
    pha ; Save it

    ; Get rid of low nibble of CRC.
    ldx #4
@shift:
    lsr crc_xorval + 1
    ror crc_xorval
    dex
    bne @shift

    ; Index into CRC table.
    plx
    lda.w kermit_crc_table,X
    eor crc_xorval
    sta crc_xorval
    lda.w kermit_crc_table + 1,X
    eor crc_xorval + 1
    sta crc_xorval + 1

    pla
    rts

; 0100110101101111

PSTR check, "123456789"
.ENDS

.SECTION "VectorsImpl"
unused:
.ENDS

; FIXME: WLA doesn't handle ROM/RAM collisions well...
; Bare .ORGA without a section also works, but at least this signifies intent.
; The user is _expected_ to overwrite these debugger vars.
.BANK 0 SLOT 1
.SECTION "Vectors" OVERWRITE ORGA VECTOR_ORG
.dw unused
.dw entry
.dw unused
.ENDS
